package mkbook

import (
	"bytes"
	"crypto/sha256"
	"fmt"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"sync"

	"github.com/go-shiori/go-epub"

	"github.com/Jictyvoo/ink_stream/internal/services/imgprocessor"
	"github.com/Jictyvoo/ink_stream/internal/services/mkbook/tmplepub"
	"github.com/Jictyvoo/ink_stream/internal/services/outdirwriter"
	"github.com/Jictyvoo/ink_stream/internal/utils"
	"github.com/Jictyvoo/ink_stream/pkg/inktypes"
)

type imageSectionData struct {
	pageData               tmplepub.ImageData
	sectionTitle, fileName string
	chapterID              string
}

type EpubMounter struct {
	epub           *epub.Epub
	outDir, tmpDir string
	styleLocation  string
	coverInfo      struct{ location, name string }
	imageSections  []imageSectionData
	outWriter      outdirwriter.WriterHandle
	sync.Mutex
}

func NewEpubMounter(
	outputDirectory string, readDirection inktypes.ReadDirection,
) (*EpubMounter, error) {
	title := filepath.Base(outputDirectory)
	if title == "." {
		asSha := sha256.Sum256([]byte(outputDirectory))
		title = string(asSha[:16])
	}
	e, err := epub.NewEpub(title)
	if err != nil {
		return nil, err
	}

	// Set the PPD to the read direction
	e.SetPpd(readDirection.String())
	e.SetAuthor("ink_stream")
	e.SetDescription("Generated by ink_stream")
	epubMounter := &EpubMounter{epub: e, outDir: outputDirectory}

	// Prepare temporary output directory for images
	if epubMounter.tmpDir, err = os.MkdirTemp("", "inkstream-epub-*"); err != nil {
		return nil, err
	}
	if epubMounter.outWriter, err = outdirwriter.NewWriterHandle(epubMounter.tmpDir); err != nil {
		return nil, err
	}

	err = epubMounter.registerMainCSS()

	return epubMounter, err
}

func (em *EpubMounter) registerMainCSS() (err error) {
	// `data:text/plain;charset=utf-8;base64,aGV5YQ==`
	var buffer bytes.Buffer
	if err = tmplepub.EpubImageStyle().Execute(&buffer, nil); err != nil {
		return err
	}

	em.styleLocation, err = writeBinaryFile("style.css", buffer.Bytes(), em.epub.AddCSS)
	return err
}

func (em *EpubMounter) Handler(filename string, callback imgprocessor.WriterCallback) error {
	// Capture chapter based on original filename directory before normalization
	chapterID := utils.SanitizeName(
		filepath.Dir(filename), ' ', nil,
		utils.DefaultInsideIgnore(), '.', '-',
	)

	// Write image to the temp output directory using the outdirwriter to avoid memory usage
	imgMetadata, absPath, err := em.outWriter.ExecuteFileWrite(filename, callback)
	if err != nil {
		return fmt.Errorf("error while processing file %s: %w", filename, err)
	}

	// Register the image in the EPUB from disk path
	var locationOnEpub string
	filename = normalizeFileName(filename)
	filename = strings.ReplaceAll(
		filename, "/", "__",
	) // This is a temporary fix due to epub lib used not supporting folders
	locationOnEpub, err = em.epub.AddImage(absPath, filename)
	if err != nil {
		return fmt.Errorf("error while writing file `%s` to epub: %w", filename, err)
	}

	// Add an image page to the EPUB using the written filename as the image source
	pageData := tmplepub.ImageData{
		ImageSrc:    locationOnEpub,
		ImageWidth:  int(imgMetadata.Width),
		ImageHeight: int(imgMetadata.Height),
	}
	return em.AddImagePage(pageData, filename, filename, chapterID)
}

func (em *EpubMounter) AddImagePage(
	pageData tmplepub.ImageData,
	sectionTitle, fileName, chapterID string,
) error {
	// Provide sensible defaults so the page renders even if caller omitted details
	if len(pageData.PanelImages) == 0 {
		pageData.PanelImages = []tmplepub.PanelImage{
			{Class: "panel-top-left", Ordinal: 2},
			{Class: "panel-top-right", Ordinal: 1},
			{Class: "panel-bottom-left", Ordinal: 4},
			{Class: "panel-bottom-right", Ordinal: 3},
		}
	}
	// Ensure BaseID is set from ImageSrc
	if pageData.BaseID == "" {
		pageData.BaseID = utils.BuildBaseID(pageData.ImageSrc)
	}
	// If viewport dimensions were not provided, use image dimensions if available
	if pageData.ViewportWidth == 0 && pageData.ImageWidth > 0 {
		pageData.ViewportWidth = pageData.ImageWidth
	}
	if pageData.ViewportHeight == 0 && pageData.ImageHeight > 0 {
		pageData.ViewportHeight = pageData.ImageHeight
	}

	em.Lock()
	defer em.Unlock()

	if em.coverInfo.name == "" || fileName < em.coverInfo.name {
		em.coverInfo.name = fileName
		em.coverInfo.location = pageData.ImageSrc
	}
	em.imageSections = append(em.imageSections, imageSectionData{
		pageData:     pageData,
		sectionTitle: sectionTitle,
		fileName:     fileName,
		chapterID:    chapterID,
	})
	return nil
}

func (em *EpubMounter) Flush() error {
	// finalize any folder analysis on the temp directory
	//_ = em.outWriter.Flush()

	if err := em.epub.SetCover(em.coverInfo.location, ""); err != nil {
		return err
	}

	slices.SortFunc(em.imageSections, func(a, b imageSectionData) int {
		return strings.Compare(a.fileName, b.fileName)
	})

	// Strategy: the first page seen for a chapter becomes the top-level section;
	// remaining pages in the same chapter become subsections under it.
	parentByChapter := make(map[string]string)
	tmpl := tmplepub.EpubImagePage()
	for _, imgSection := range em.imageSections {
		var buf strings.Builder
		if err := tmpl.Execute(&buf, imgSection.pageData); err != nil {
			return err
		}

		if parent, ok := parentByChapter[imgSection.chapterID]; ok {
			// Subsequent pages: add as subsection under the first page's section
			if _, err := em.epub.AddSubSection(
				parent, buf.String(),
				imgSection.sectionTitle,
				imgSection.fileName,
				em.styleLocation,
			); err != nil {
				return fmt.Errorf("error while adding subsection: %w", err)
			}
			continue
		}

		sectionTitle := "root"
		if imgSection.chapterID != "." && imgSection.chapterID != "" {
			sectionTitle = imgSection.chapterID
		}
		// First page of this chapter: add as the parent section
		parentFN, err := em.epub.AddSection(
			buf.String(),
			sectionTitle,
			imgSection.fileName,
			em.styleLocation,
		)
		if err != nil {
			return fmt.Errorf("error while adding section: %w", err)
		}
		parentByChapter[imgSection.chapterID] = parentFN
	}

	file, err := os.Create(em.outDir + ".epub")
	if err != nil {
		return err
	}
	defer file.Close()
	// Cleanup temp directory regardless of write outcome
	defer os.RemoveAll(em.tmpDir)

	if _, err = em.epub.WriteTo(file); err != nil {
		return fmt.Errorf("error while writing epub: %w", err)
	}
	return err
}
